import ballerina/io;
import ballerina/lang.value;
import ballerina/sql;
import ballerina/time;
import ballerinax/java.jdbc;

class GameDB {
    jdbc:Client jdbcClient;

    function init(string file) returns error? {
        io:println("Initializing functions...");

        self.jdbcClient = check new ("jdbc:h2:file:./" + file, "user", "pass");

        // Turn on tracing
        _ = check self.jdbcClient->execute(`SET TRACE_LEVEL_SYSTEM_OUT 1`);

        // Runs the prerequisite setup for the example.
        _ = check self.jdbcClient->execute(`CREATE TABLE IF NOT EXISTS Games(
            id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY, 
            playerOne VARCHAR(80), playerTwo VARCHAR(80),
            board VARCHAR(320),
            playerToMove VARCHAR(80),
            createdAt TIMESTAMP,
            PRIMARY KEY (id))`);

        io:println("Completed");
    }

    function raw() returns jdbc:Client {
        return self.jdbcClient;
    }

    function insert(string playerOne, string playerTwo) returns int|error {
        io:println("GameDB::insert");
        string[] board = [ "", "", "", "", "", "", "", "", "" ];
        time:Utc createdAt = time:utcNow();
        sql:ParameterizedQuery query = 
            `INSERT INTO Games (playerOne, playerTwo, board, playerToMove, createdAt) 
             VALUES (${playerOne},${playerTwo}, ${board.toJsonString()}, ${playerOne}, ${createdAt})`;
        io:print("SQL:"); io:println(query);
        sql:ExecutionResult result = check self.jdbcClient->execute(query);
        io:println("SQL RESULT: " + result.toString());
        return <int>result.lastInsertId;
    }

    function game(int id) returns Game|error {
        io:println("GameDB::game(" + id.toString() + ")");
        Game|error result = check self.jdbcClient->queryRow(`SELECT * FROM Games where id = ${id}`);
        io:println(result);
        if result is error {
            io:print("SQL ERROR: "); io:println(result);
        }
        else {
            io:println(result);
        }
        io:println("GameDB::game() returning");
        return result;
    }

    function retrieve(string clause = "") returns Game[]|error {
        sql:ParameterizedQuery query = `SELECT * FROM Games`;
        if clause.length() > 0 {
            query = `SELECT * FROM Games WHERE ${clause}`;
        }

        Game[] games = [];
        stream<Game,error?> results = self.jdbcClient->query(query);
        check from Game game in results
            do {
                io:println("Found " + game.toString());
                games.push(game);
            };
        return games;
    }

    function update(Game game) returns error? {
        io:println(game.board);
        sql:ParameterizedQuery query = `UPDATE Games SET playerToMove=${game.playerToMove}, 
             board = ${game.board} WHERE id = ${game.id}`;
        io:print("SQL:"); io:println(query);
        _ = check self.jdbcClient->execute(query);
     }

    function delete(int id) returns error? {
        _ = check self.jdbcClient->execute(`DELETE FROM Games WHERE id = ${id}`);
    }

    function drop() returns error? {
        _ = check self.jdbcClient->execute(`DROP TABLE Games`);
    }

    function close() returns error? {
        check self.jdbcClient.close();
    }
}

final GameDB gamedb;
function init() returns error? {
    gamedb = check new GameDB("games");
}

public function getGames() returns Game[]|error {
    io:println("getGames()");
    return check gamedb.retrieve();
}
public function getGame(int id) returns Game|error {
    io:print("getGame(id:" + value:toString(id) + "): ");
    Game game = check gamedb.game(id);
    io:println(" returns " + game.toString());
    return game;
}
public function createGame(string p1, string p2) returns Game|error {
    io:println("createGame(p1:" + p1 + ",p2:" + p2 + ")");

    // p1 is X and board always first to move; TODO randomize this

    int id = check gamedb.insert(p1, p2);
    return check gamedb.game(id);
}
function checkWinner(Game game, string player) returns boolean|error {
    io:println("Checking for winner in game " + value:toString(game.id) + " for player " + player);

    var winPatterns = [
        // Down
        [0, 3, 6],
        [1, 4, 7],
        [2, 5, 8],
        // Across
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
        // Diagonal
        [0, 4, 8],
        [2, 4, 6]
    ];

    string[] board = check game.board.fromJsonStringWithType();
    foreach int[] pattern in winPatterns {
        io:print("Checking pattern " + value:toBalString(pattern) + ": ");

        boolean win = true;
        pattern.forEach(function (int pos) {
            if (board[pos] != player) {
                win = false;
            }
        });
        io:println(win);

        if (win) {
            return true;
        }
    }

    return false;
}
function checkCats(Game game) returns boolean|error { 
    io:println("Checking for cats game in game " + value:toString(game.id));

    // Brute-force method: if any space is open, it's not cats yet
    string[] board = check game.board.fromJsonStringWithType();
    var openSqs = board.filter(function (anydata sq) returns boolean { return (value:toString(sq) == ""); });
    io:println(value:toString(openSqs.length()) + " squares are open");
    return openSqs.length() == 0;

    // TODO: optimize this to detect when there's an open square on an unwinnable game
    // so the players don't have to go through the motions
}
public function makeMove(Game game, Move move) returns Game|error {
    io:println("makeMove(game:" + value:toBalString(game) + ", move:" + value:toBalString(move) + ")");

    ///////////////////////
    // Process the move
    int boardPos = move.boardPosition;

    // Game must not be over
    if (game.winner != () ) {
        return error("Game is completed; " + (game.winner ?: "") + " won.");
    }

    // It must be this player's turn
    if (game.playerToMove != () && game.playerToMove != move.player) {
        return error("Illegal move: Not your turn!");
    }

    string[] board = check game.board.fromJsonStringWithType();
    // That position cannot already be occupied
    if (board[boardPos] != "") {
        return error("Illegal move: Occupied space!");
    }

    // Put the player in that given square
    board[boardPos] = move.player;
    game.board = board.toJsonString();
    // Update the player moving
    game.playerToMove = (game.playerOne == move.player ? game.playerTwo : game.playerOne);
    // Update the most-recent message
    game.message = "Last move: " + move.player + " takes square " + value:toString(move.boardPosition);

    ///////////////////////
    // Check for winner
    if (check checkWinner(game, game.playerOne)) {
        game.winner = game.playerOne;
        game.message += "; " + game.playerOne + " WINS!";
    }
    else if (check checkWinner(game, game.playerTwo)) {
        game.winner = game.playerTwo;
        game.message += "; " + game.playerTwo + " WINS!";
    }
    else if (check checkCats(game)) {
        game.winner = "(NOBODY)";
        game.message += "; cats game (draw)!";
    }

    io:println(`Updating game: ${game}`);
    _ = check gamedb.update(game);
    return game;
}
